# DSA
This repo contains DSA informations


Algorithms are divided into 2 broad categories:

### Data Structure specific algorithms

### General algorithms/techniques

Implement all the algorithms unless otherwise specified.


#Data Structure specific algorithms:

## I.LINEAR DATA STRUCTURES

# 1. Arrays
   * Sorting:
      QuickSort: Efficient average-case time complexity (O(nlog n))
      MergeSort: Stable sort, useful when order matters (O(nlog n))

   * Searching:
      Binary Search: Fast search in sorted arrays (O(log n))

   * Two Pointers:
      In-place manipulation, often for sorted arrays (e.g., removing duplicates)

   * Sliding Window:
      Subarray problems, finding maximum/minimum within a window

# 2. Linked Lists
   * Traversal:
      Iterate through the list, understand the node structure
    
   * Insertion/Deletion:
      At beginning, end, or at a specific position
    
   * Reversal:
      In-place reversal, recursive and iterative approaches

   * Cycle Detection:
      Floyd's Tortoise and Hare algorithm
    
# 3. Stacks
   Implementation not needed. Just understand following
    1.Push
    2.Pop
    3.Peek 

# 4. Queues
   *  Implementation not needed. Just understand following:
      Enqueue/Dequeue Operations

# 5. Union-Find (Disjoint Set)
  *  Implement Union-Find from scratch
  *  Find/Union Operations
  *  Cycle Detection in undirected graphs
  
## II.NON-LINEAR DATA STRUCTURES

# 1. Trees (Binary Trees, Binary Search Trees, etc.)
   * Traversal:
      Inorder, Preorder, Postorder (recursive and iterative)
   * Searching:
      Find a node with a given value (especially in BSTs)

# 2.Hash Tables (Hash Maps/Sets)
   * Implementation not needed. Just understand following:
        Understand how hash functions work
        Insertion/Deletion/Lookup
        Collision Handling

# 3. Graphs
  * Traversal:
        Breadth-First Search (BFS)
        Depth-First Search (DFS)
  * Shortest Path:
        Dijkstra's Algorithm
  *  Cycle Detection:
        DFS

#  4. Heaps (Priority Queues)
   * Implementation not needed. Just understand following:
      1.Insertion/Deletion (extract-min/max)
      2.Building a Heap

   * Top K Elements:
      Using a heap to find k largest/smallest elements

#  5. Tries
   * Implement Trie from scratch

   *Insertion/Searching:
      For words/prefixes

   * Autocompletion:
      Using a trie for word suggestions


#  General algorithms/techniques
